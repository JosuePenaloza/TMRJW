JW\BrowserWindow.xaml.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Navigation;
using System.Windows.Media.Imaging;
using System.Windows.Input; // añadido para MouseButtonEventArgs
using System.Net.Http;
using System.IO;
using System.Runtime.InteropServices;

namespace TMRJW
{
    // Pequeña clase para representar imágenes cacheadas en disco
    internal class CachedImage
    {
        public string FilePath { get; set; } = string.Empty;
        public BitmapImage Image { get; set; } = null!;
        public override string ToString() => Path.GetFileName(FilePath);
    }

    // Objeto expuesto a JavaScript => debe ser COM visible
    [ComVisible(true)]
    public class ScriptBridge
    {
        private readonly BrowserWindow _parent;
        public ScriptBridge(BrowserWindow parent) => _parent = parent;
        // Método invocado desde JS: recibe la URL de la imagen
        public void ImageClicked(string url) => _parent.OnImageUrlClicked(url);
    }

    public partial class BrowserWindow : Window
    {
        private Action<BitmapImage>? _onImageSelected;
        private CancellationTokenSource? _cts;
        private static readonly HttpClient s_http = new HttpClient();

        // Nuevos campos para coordinar descargas/proyección
        internal Uri? _lastClickedImageUri;
        internal bool _isDownloadingImage = false;
        internal bool _projectionWaitingForImage = false;

        public BrowserWindow()
        {
            InitializeComponent();
            UrlBox.Text = "https://wol.jw.org/es/wol/meetings/r4/lp-s/";

            // permitir seleccionar con un solo click (MouseLeftButtonUp)
            ImagesListBox.MouseLeftButtonUp += ImagesListBox_MouseLeftButtonUp;

            // silenciar errores de script en el WebBrowser
            WebBrowserControl.Navigated += WebBrowserControl_Navigated;

            // exponer objeto COM para que JS pueda llamar a window.external.ImageClicked(...)
            try
            {
                WebBrowserControl.ObjectForScripting = new ScriptBridge(this);
            }
            catch
            {
                // ignorar si no es posible
            }
        }

        public void SetImageSelectedCallback(Action<BitmapImage> callback)
        {
            _onImageSelected = callback;
        }

        private void BtnGo_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var url = UrlBox.Text.Trim();
                if (!string.IsNullOrEmpty(url))
                    WebBrowserControl.Navigate(url);
            }
            catch { }
        }

        private async void WebBrowserControl_LoadCompleted(object sender, NavigationEventArgs e)
        {
            await RefreshImagesFromCurrentPageAsync();
            InjectClickScript(); // inyectar handlers para clicks dentro de la página
        }

        private async Task RefreshImagesFromCurrentPageAsync()
        {
            _cts?.Cancel();
            _cts = new CancellationTokenSource();

            try
            {
                string? url = WebBrowserControl.Source?.AbsoluteUri ?? UrlBox.Text;
                if (string.IsNullOrWhiteSpace(url)) return;

                UrlBox.Text = url;

                var uris = await OnlineLibraryHelper.ExtractImageUrisFromPageAsync(url, _cts.Token).ConfigureAwait(false);
                if (!uris.Any())
                {
                    await Dispatcher.InvokeAsync(() => ImagesListBox.ItemsSource = null);
                    return;
                }

                var list = uris.Take(20).ToList();
                var images = await OnlineLibraryHelper.DownloadImagesAsync(list, _cts.Token).ConfigureAwait(false);

                await Dispatcher.InvokeAsync(() =>
                {
                    ImagesListBox.ItemsSource = images;
                });
            }
            catch
            {
                // ignorar
            }
        }

        // Click en inventario: solo previsualizar (no proyectar)
        private void ImagesListBox_MouseLeftButtonUp(object? sender, MouseButtonEventArgs e)
        {
            var item = ImagesListBox.SelectedItem;
            if (item is CachedImage ci)
            {
                try
                {
                    PreviewImage.Source = ci.Image;
                }
                catch { }
            }
            else if (item is BitmapImage bi)
            {
                // compatibilidad: si hay BitmapImage suelta
                try { PreviewImage.Source = bi; } catch { }
            }
        }

        // Doble click en inventario => proyectar (callback)
        private void ImagesListBox_MouseDoubleClick(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            var item = ImagesListBox.SelectedItem;
            if (item is CachedImage ci)
            {
                try { _onImageSelected?.Invoke(ci.Image); } catch { }
            }
            else if (item is BitmapImage bi)
            {
                try { _onImageSelected?.Invoke(bi); } catch { }
            }
        }

        // Silenciar errores de script en el WebBrowser (usa ActiveX.Silent)
        private void WebBrowserControl_Navigated(object? sender, NavigationEventArgs e)
        {
            try
            {
                dynamic? activeX = WebBrowserControl.GetType().InvokeMember("ActiveXInstance",
                    System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic,
                    null, WebBrowserControl, new object[] { });

                if (activeX != null)
                {
                    try { activeX.Silent = true; } catch { /* ignorar si la propiedad no existe */ }
                }
            }
            catch
            {
                // ignorar si no se puede establecer Silent
            }

            // también intentar inyectar script después de navegación
            InjectClickScript();
        }

        // Método llamado por ScriptBridge cuando JS hace click en una imagen dentro de la página
        // Ahora guarda la última URL, descarga, guarda en cache y añade al inventario; NO proyecta automáticamente.
        public async void OnImageUrlClicked(string url)
        {
            if (string.IsNullOrWhiteSpace(url)) return;

            try
            {
                // resolver URL relativa respecto a la página si es necesario
                Uri finalUri;
                try
                {
                    var baseUri = WebBrowserControl.Source ?? new Uri(UrlBox.Text);
                    finalUri = new Uri(baseUri, url);
                }
                catch
                {
                    if (!Uri.TryCreate(url, UriKind.Absolute, out Uri? tmp) || tmp == null)
                        return;
                    finalUri = tmp;
                }

                _lastClickedImageUri = finalUri;
                _isDownloadingImage = true;

                // descargar bytes
                byte[]? bytes = null;
                try { bytes = await s_http.GetByteArrayAsync(finalUri).ConfigureAwait(false); } catch { bytes = null; }
                _isDownloadingImage = false;

                if (bytes != null && bytes.Length > 0)
                {
                    // guardar en cache y crear BitmapImage desde archivo cacheado
                    var cachedPath = await SaveBytesToCacheAsync(bytes, Path.GetExtension(finalUri.LocalPath));
                    if (!string.IsNullOrEmpty(cachedPath))
                    {
                        var bi = LoadBitmapFromFileCached(cachedPath);
                        if (bi != null)
                        {
                            var ci = new CachedImage { FilePath = cachedPath, Image = bi };
                            await Dispatcher.InvokeAsync(() =>
                            {
                                ImagesListBox.Items.Add(ci);
                                ImagesListBox.SelectedItem = ci;
                                PreviewImage.Source = ci.Image;
                                // no llamamos al callback; proyección solo en doble click del inventario
                                if (_projectionWaitingForImage)
                                {
                                    try { _onImageSelected?.Invoke(ci.Image); } catch { }
                                    _projectionWaitingForImage = false;
                                }
                            });
                            return;
                        }
                    }
                }

                await Dispatcher.InvokeAsync(() =>
                {
                    MessageBox.Show("No se pudo descargar la imagen seleccionada desde la web.", "Error descarga", MessageBoxButton.OK, MessageBoxImage.Warning);
                });
            }
            catch
            {
                _isDownloadingImage = false;
            }
        }

        // Helper: carga BitmapImage desde archivo cache (OnLoad para liberar file handle)
        private BitmapImage? LoadBitmapFromFileCached(string path)
        {
            try
            {
                var bi = new BitmapImage();
                using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    bi.BeginInit();
                    bi.CacheOption = BitmapCacheOption.OnLoad;
                    bi.StreamSource = fs;
                    bi.EndInit();
                    bi.Freeze();
                }
                return bi;
            }
            catch { return null; }
        }

        // Guarda bytes en la carpeta de cache y devuelve la ruta
        private async Task<string> SaveBytesToCacheAsync(byte[] bytes, string? extension)
        {
            try
            {
                var dir = GetCacheDirectory();
                Directory.CreateDirectory(dir);
                string ext = string.IsNullOrWhiteSpace(extension) ? ".jpg" : extension;
                if (!ext.StartsWith(".")) ext = "." + ext;
                string fileName = Guid.NewGuid().ToString("N") + ext;
                string path = Path.Combine(dir, fileName);
                await File.WriteAllBytesAsync(path, bytes).ConfigureAwait(false);
                return path;
            }
            catch { return string.Empty; }
        }

        // Obtiene la carpeta de cache (LocalApplicationData\TMRJW\cache)
        private string GetCacheDirectory()
        {
            var local = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            return Path.Combine(local, "TMRJW", "cache");
        }

        // Inyecta un script sencillo que escucha clicks y llama a window.external.ImageClicked(url)
        private void InjectClickScript()
        {
            try
            {
                dynamic doc = WebBrowserControl.Document;
                if (doc == null) return;

                string js = @"
                        (function(){
                            try {
                                function sendUrl(u){ try { if(u) window.external.ImageClicked(u); } catch(e){} }
                                document.addEventListener('click', function(ev){
                                    var t = ev.target;
                                    while(t && t.tagName !== 'IMG') { t = t.parentElement; }
                                    if(t && t.src) { sendUrl(t.src); return; }
                                    // fallback: si el elemento tiene background-image en estilo, intentar extraer url(...)
                                    if(t){
                                        var bg = window.getComputedStyle(t).backgroundImage;
                                        if(bg && bg.indexOf('url(') !== -1){
                                            var m = /url\\(['""]?(.*?)['""]?\\)/.exec(bg);
                                            if(m && m[1]) sendUrl(m[1]);
                                        }
                                    }
                                }, true);
                            } catch(e){}
                        })();";

                // Ejecutar en el contexto de la página
                try
                {
                    doc.parentWindow.execScript(js, "JavaScript");
                }
                catch
                {
                    // fallback para algunos documentos
                    try { WebBrowserControl.InvokeScript("eval", new object[] { js }); } catch { }
                }
            }
            catch
            {
                // ignorar
            }
        }

        // Exponer método para limpiar cache (se puede usar desde Ajustes)
        public void ClearCache()
        {
            try
            {
                var dir = GetCacheDirectory();
                if (Directory.Exists(dir))
                {
                    Directory.Delete(dir, true);
                    Directory.CreateDirectory(dir);
                }
            }
            catch { }
        }
    }
}